<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tanks: Armored Bricks</title>
    <style>
        body { 
            margin: 0; 
            padding: 0;
            background: #222; 
            overflow: hidden; 
            touch-action: none; 
            font-family: 'Arial', sans-serif; 
            -webkit-user-select: none; 
            user-select: none;
            -webkit-text-size-adjust: none;
            text-size-adjust: none;
        }
        html, body {
            width: 100%;
            height: 100%;
            position: fixed;
        }
        canvas { 
            display: block; 
            background: #333;
            width: 100%;
            height: 100%;
        }
        
        /* Меню */
        #menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            transition: opacity 0.3s;
        }
        
        .menu-title {
            font-size: 48px;
            margin-bottom: 40px;
            color: #ffcc00;
            text-shadow: 0 0 10px rgba(255, 204, 0, 0.5);
            text-align: center;
        }
        
        .mode-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 90%;
            max-width: 400px;
        }
        
        .mode-btn {
            padding: 20px;
            font-size: 24px;
            border: none;
            border-radius: 10px;
            background: #444;
            color: white;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }
        
        .mode-btn:hover {
            background: #555;
            transform: scale(1.05);
        }
        
        .mode-btn.active {
            background: #2e7d32;
            box-shadow: 0 0 15px rgba(46, 125, 50, 0.5);
        }
        
        .mode-btn.disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: #333;
        }
        
        .mode-btn.disabled:hover {
            transform: none;
            background: #333;
        }
        
        /* Модальное окно выбора сложности */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            display: none;
            justify-content: center;
            align-items: center;
        }
        
        .modal-content {
            background: #333;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        
        .modal-title {
            color: #ffcc00;
            font-size: 28px;
            margin-bottom: 20px;
        }
        
        .difficulty-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin: 20px 0;
        }
        
        .diff-btn {
            padding: 15px;
            background: #444;
            color: white;
            border: 2px solid #555;
            border-radius: 10px;
            cursor: pointer;
            font-size: 20px;
            transition: all 0.2s;
        }
        
        .diff-btn:hover {
            background: #555;
            transform: scale(1.05);
        }
        
        .diff-btn.active {
            border-color: #ffcc00;
            background: #555;
            box-shadow: 0 0 10px rgba(255, 204, 0, 0.3);
        }
        
        .diff-description {
            font-size: 14px;
            color: #aaa;
            margin-top: 5px;
            text-align: left;
            padding-left: 10px;
        }
        
        .start-btn {
            padding: 20px;
            font-size: 28px;
            background: linear-gradient(45deg, #2e7d32, #4caf50);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
            font-weight: bold;
            width: 90%;
            max-width: 400px;
        }
        
        .start-btn:hover {
            background: linear-gradient(45deg, #388e3c, #66bb6a);
            transform: scale(1.05);
        }
        
        .back-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: #444;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 300;
        }
        
        /* Игровые элементы */
        .score { 
            position: absolute; 
            width: 100%; 
            text-align: center; 
            font-size: 24px; 
            font-weight: bold; 
            z-index: 100; 
            color: #fff; 
            pointer-events: none; 
            text-shadow: 2px 2px #000; 
        }
        #score1 { 
            top: 160px; 
            left: 0;
        }
        #score2 { 
            bottom: 160px; 
            left: 0;
        }
        
        /* Управление для книжной ориентации - танки по бокам */
        .joy-zone, .btn-fire { 
            position: fixed; 
            border-radius: 50%; 
            z-index: 200; 
            touch-action: none; 
            width: 120px; 
            height: 120px; 
        }
        .joy-zone { 
            background: rgba(255,255,255,0.05); 
            border: 2px solid #555; 
        }
        .stick { 
            position: absolute; 
            width: 50px; 
            height: 50px; 
            border-radius: 50%; 
            top: 35px; 
            left: 35px; 
            pointer-events: none; 
            background: rgba(255,255,255,0.2); 
            transition: transform 0.1s; 
        }
        .btn-fire { 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-weight: bold; 
            font-size: 16px; 
            border: 4px solid #333; 
            width: 100px; 
            height: 100px; 
            transition: background-color 0.1s; 
        }
        
        /* Зеленая область для кнопки огня игрока 1 (слева) */
        #p1-fire {
            background: rgba(0,255,0,0.2);
            box-shadow: 0 0 0 6px rgba(0, 255, 0, 0.2);
        }
        
        /* Красная область для кнопки огня игрока 2 (справа) */
        #p2-fire {
            background: rgba(255,0,0,0.2);
            box-shadow: 0 0 0 6px rgba(255, 0, 0, 0.2);
        }
        
        .fire-text { 
            display: inline-block; 
        }
        
        /* Индикатор режима */
        #game-mode-indicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 18px;
            z-index: 300;
        }
        
        /* Уведомление о ориентации - теперь предупреждаем об альбомной */
        #orientation-warning {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            color: white;
            font-size: 24px;
            text-align: center;
            padding: 40% 20px 0;
            line-height: 1.5;
        }
        
        /* Инструкция для управления */
        .controls-hint {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #aaa;
            font-size: 14px;
            text-align: center;
            z-index: 150;
            width: 100%;
        }
    </style>
</head>
<body>
    <!-- Предупреждение об ориентации - теперь для альбомной -->
    <div id="orientation-warning">
        Пожалуйста, поверните устройство в портретную (книжную) ориентацию!<br>
        Игра предназначена для вертикального положения.
    </div>
    
    <!-- Модальное окно выбора сложности -->
    <div id="difficulty-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 class="modal-title">Выберите сложность ИИ</h2>
            <div class="difficulty-buttons">
                <button class="diff-btn" data-diff="easy">
                    Легко
                    <div class="diff-description">• Медленная реакция<br>• Редко стреляет<br>• Легко победить</div>
                </button>
                <button class="diff-btn" data-diff="medium">
                    Средне
                    <div class="diff-description">• Нормальная реакция<br>• Средняя точность<br>• Сбалансировано</div>
                </button>
                <button class="diff-btn" data-diff="hard">
                    Сложно
                    <div class="diff-description">• Быстрая реакция<br>• Высокая точность<br>• Сложно победить</div>
                </button>
                <button class="diff-btn active" data-diff="insane">
                    Безумие
                    <div class="diff-description">• Молниеносная реакция<br>• Почти не промахивается<br>• Экстремальная сложность</div>
                </button>
            </div>
            <button id="confirm-difficulty" style="
                padding: 15px 30px;
                font-size: 20px;
                background: linear-gradient(45deg, #2e7d32, #4caf50);
                color: white;
                border: none;
                border-radius: 10px;
                cursor: pointer;
                margin-top: 20px;
                font-weight: bold;
                width: 100%;
            ">НАЧАТЬ ИГРУ</button>
        </div>
    </div>
    
    <!-- Меню выбора режима -->
    <div id="menu">
        <h1 class="menu-title">БРОНЕТАНКИ</h1>
        <div class="mode-buttons">
            <button class="mode-btn active" data-mode="pvp">1 на 1 (PvP)</button>
            <button class="mode-btn" data-mode="pve">Против ИИ (PvE)</button>
            <button class="mode-btn disabled" data-mode="survival">Выживание (в разработке)</button>
        </div>
        
        <button class="start-btn" id="start-game">НАЧАТЬ ИГРУ</button>
    </div>
    
    <!-- Игровое поле -->
    <div id="score1" class="score">0</div>
    <div id="score2" class="score">0</div>
    <div id="game-mode-indicator" style="display: none;">PvP</div>
    <canvas id="gameCanvas"></canvas>
    
    <!-- Инструкция -->
    <div class="controls-hint" style="display: none;">
        Левая сторона: Зеленый танк • Правая сторона: Красный танк
    </div>
    
    <!-- Управление игроком 1 (слева, зеленый) - ОГНЬ ВНИЗУ, ДЖОЙСТИК ВВЕРХУ -->
    <div id="p1-controls">
        <div id="p1-fire" class="btn-fire" style="left: 20px; bottom: 20px;">
            <span class="fire-text">ОГОНЬ</span>
        </div>
        <div id="p1-joy" class="joy-zone" style="left: 20px; top: 20px;">
            <div id="p1-stick" class="stick" style="border: 2px solid #0f0;"></div>
        </div>
    </div>
    
    <!-- Управление игроком 2 (справа, красный) - ОГНЬ ВНИЗУ, ДЖОЙСТИК ВВЕРХУ -->
    <div id="p2-controls">
        <div id="p2-fire" class="btn-fire" style="right: 20px; bottom: 20px;">
            <span class="fire-text">ОГОНЬ</span>
        </div>
        <div id="p2-joy" class="joy-zone" style="right: 20px; top: 20px;">
            <div id="p2-stick" class="stick" style="border: 2px solid #f00;"></div>
        </div>
    </div>

<script>
// ========== КОНФИГУРАЦИЯ ==========
const CONFIG = {
    TANK: {
        SPEED: 2.8,
        RADIUS: 20,
        SLOW_RECOVERY: 0.003,
        INITIAL_HP: 3
    },
    BULLET: {
        SPEED: 8,
        RADIUS: 4,
        PLAYER_COLOR: 'yellow',
        SOS_COLOR: '#00fbff'
    },
    BRICK: {
        WIDTH: 25,
        HEIGHT: 15,
        COLOR: '#a52a2a',
        BORDER_COLOR: '#5d1a1a'
    },
    SOS: {
        SEQUENCE: '...---...',
        MAX_BUFFER: 9,
        DOT_MAX_TIME: 250,
        DASH_MIN_TIME: 400,
        TANK_COUNT: 6,
        TANK_LIFE: 600,
        TANK_SPEED: 1.8
    },
    PARTICLES: {
        COUNT_ON_EXPLOSION: 15,
        FADE_SPEED: 0.02
    },
    AUDIO: {
        VOLUME: 0.05,
        FADE_DURATION: 0.1
    },
    AI: {
        UPDATE_INTERVAL: 100,
        DIFFICULTY: {
            easy: { 
                accuracy: 0.3, 
                reaction: 800, 
                aggression: 0.3, 
                dodgeChance: 0.2,
                shootCooldown: 1200,
                speed: 0.4
            },
            medium: { 
                accuracy: 0.6, 
                reaction: 500, 
                aggression: 0.5, 
                dodgeChance: 0.4,
                shootCooldown: 900,
                speed: 0.5
            },
            hard: { 
                accuracy: 0.8, 
                reaction: 300, 
                aggression: 0.7, 
                dodgeChance: 0.6,
                shootCooldown: 700,
                speed: 0.6
            },
            insane: { 
                accuracy: 0.95, 
                reaction: 150, 
                aggression: 0.9, 
                dodgeChance: 0.8,
                shootCooldown: 500,
                speed: 0.7
            }
        }
    }
};

// ========== ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ ==========
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

let bullets = [];
let particles = [];
let sosTanks = [];
let bricks = [];
let tanks = [];
let gameMode = 'pvp';
let aiDifficulty = 'insane';
let aiPlayer = null;
let lastAIUpdate = 0;
let isGameActive = false;
let isLandscapeMode = false;
let selectedMode = 'pvp';

// ========== КЛАСС ТАНКА ==========
class Tank {
    constructor(id, color, isLeftPlayer, isAI = false) {
        this.id = id;
        this.color = color;
        this.isLeftPlayer = isLeftPlayer;
        this.isAI = isAI;
        this.reset();
    }
    
    reset() {
        this.x = this.isLeftPlayer ? 100 : canvas.width - 100;
        this.y = canvas.height / 2;
        this.angle = this.isLeftPlayer ? 0 : Math.PI;
        this.score = 0;
        this.hp = CONFIG.TANK.INITIAL_HP;
        this.maxHp = CONFIG.TANK.INITIAL_HP;
        this.dx = 0;
        this.dy = 0;
        this.slow = 1;
        this.sosBuffer = [];
        this.lastDownTime = 0;
        this.lastShotTime = 0;
        this.shootCooldown = 800;
    }
    
    get isAlive() {
        return this.hp > 0;
    }
}

// ========== КЛАСС ИИ ==========
class AI {
    constructor(tank, difficulty = 'insane') {
        this.tank = tank;
        this.difficulty = difficulty;
        this.config = CONFIG.AI.DIFFICULTY[difficulty];
        this.state = 'patrol';
        this.lastDecisionTime = 0;
        this.dodgeTimer = 0;
        this.patrolPoints = [];
        this.waypointIndex = 0;
        
        this.tank.shootCooldown = this.config.shootCooldown;
    }
    
    update(targetTank) {
        const now = Date.now();
        if (now - this.lastDecisionTime < this.config.reaction) {
            return;
        }
        
        this.lastDecisionTime = now;
        
        if (!this.tank.isAlive) {
            this.tank.dx = 0;
            this.tank.dy = 0;
            return;
        }
        
        const distance = Math.hypot(targetTank.x - this.tank.x, targetTank.y - this.tank.y);
        
        if (this.shouldDodge()) {
            this.dodgeBullets();
            return;
        }
        
        if (distance < 150) {
            this.state = 'retreat';
            this.retreatFrom(targetTank);
        } else if (distance < 300) {
            this.state = 'attack';
            this.attackTarget(targetTank);
        } else {
            this.state = 'patrol';
            this.patrol();
        }
        
        this.handleShooting(targetTank);
    }
    
    shouldDodge() {
        for (const bullet of bullets) {
            if (bullet.owner !== this.tank.id) {
                const distance = Math.hypot(bullet.x - this.tank.x, bullet.y - this.tank.y);
                if (distance < 80 && Math.random() < this.config.dodgeChance) {
                    return true;
                }
            }
        }
        return false;
    }
    
    dodgeBullets() {
        let closestBullet = null;
        let minDistance = Infinity;
        
        for (const bullet of bullets) {
            if (bullet.owner !== this.tank.id) {
                const distance = Math.hypot(bullet.x - this.tank.x, bullet.y - this.tank.y);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestBullet = bullet;
                }
            }
        }
        
        if (closestBullet) {
            const bulletAngle = closestBullet.angle;
            const dodgeAngle = bulletAngle + Math.PI / 2 * (Math.random() > 0.5 ? 1 : -1);
            
            this.tank.dx = Math.cos(dodgeAngle) * 0.6 * this.config.speed;
            this.tank.dy = Math.sin(dodgeAngle) * 0.6 * this.config.speed;
            this.dodgeTimer = 10;
        }
    }
    
    attackTarget(target) {
        const moveChance = Math.random() < this.config.aggression ? 0.8 : 0.4;
        
        if (moveChance > 0.5) {
            const angleToTarget = Math.atan2(target.y - this.tank.y, target.x - this.tank.x);
            this.tank.dx = Math.cos(angleToTarget) * 0.5 * this.config.speed;
            this.tank.dy = Math.sin(angleToTarget) * 0.5 * this.config.speed;
        } else {
            this.tank.dx = 0;
            this.tank.dy = 0;
        }
        
        this.tank.angle = Math.atan2(target.y - this.tank.y, target.x - this.tank.x);
    }
    
    retreatFrom(target) {
        const angleFromTarget = Math.atan2(this.tank.y - target.y, this.tank.x - target.x);
        const randomAngle = angleFromTarget + (Math.random() - 0.5) * 0.5;
        
        this.tank.dx = Math.cos(randomAngle) * 0.4 * this.config.speed;
        this.tank.dy = Math.sin(randomAngle) * 0.4 * this.config.speed;
        this.tank.angle = Math.atan2(target.y - this.tank.y, target.x - this.tank.x);
    }
    
    patrol() {
        if (this.patrolPoints.length === 0) {
            this.generatePatrolPoints();
        }
        
        const currentPoint = this.patrolPoints[this.waypointIndex];
        const distance = Math.hypot(currentPoint.x - this.tank.x, currentPoint.y - this.tank.y);
        
        if (distance < 40) {
            this.waypointIndex = (this.waypointIndex + 1) % this.patrolPoints.length;
        }
        
        const targetPoint = this.patrolPoints[this.waypointIndex];
        const angleToPoint = Math.atan2(targetPoint.y - this.tank.y, targetPoint.x - this.tank.x);
        
        this.tank.dx = Math.cos(angleToPoint) * 0.3 * this.config.speed;
        this.tank.dy = Math.sin(angleToPoint) * 0.3 * this.config.speed;
        this.tank.angle = angleToPoint;
    }
    
    generatePatrolPoints() {
        const top = 100;
        const bottom = canvas.height - 100;
        const left = this.tank.isLeftPlayer ? 80 : canvas.width - 80;
        
        this.patrolPoints = [
            { x: left, y: top + 100 },
            { x: left, y: bottom - 100 },
            { x: left + (this.tank.isLeftPlayer ? 40 : -40), y: canvas.height / 2 }
        ];
        
        this.waypointIndex = 0;
    }
    
    handleShooting(target) {
        const now = Date.now();
        
        if (now - this.tank.lastShotTime < this.tank.shootCooldown) {
            return;
        }
        
        const distance = Math.hypot(target.x - this.tank.x, target.y - this.tank.y);
        const distanceFactor = Math.max(0, 1 - distance / 500);
        const shootChance = this.config.accuracy * distanceFactor * (Math.random() * 0.3 + 0.85);
        const stateBonus = this.state === 'attack' ? 0.3 : 0;
        
        if (Math.random() < shootChance + stateBonus) {
            this.shoot();
        }
    }
    
    shoot() {
        const now = Date.now();
        this.tank.lastShotTime = now;
        
        const inaccuracy = (1 - this.config.accuracy) * 0.3;
        const angleVariation = (Math.random() - 0.5) * inaccuracy;
        
        bullets.push({
            x: this.tank.x + Math.cos(this.tank.angle + angleVariation) * 30,
            y: this.tank.y + Math.sin(this.tank.angle + angleVariation) * 30,
            angle: this.tank.angle + angleVariation,
            owner: this.tank.id,
            isFromSOS: false
        });
        
        AudioManager.playShoot();
    }
}

// ========== ПРОВЕРКА ОРИЕНТАЦИИ ==========
function checkOrientation() {
    const warning = document.getElementById('orientation-warning');
    const controlsHint = document.querySelector('.controls-hint');
    
    if (window.innerWidth > window.innerHeight) {
        isLandscapeMode = true;
        warning.style.display = 'block';
        menu.style.display = 'none';
        backBtn.style.display = 'none';
        if (controlsHint) controlsHint.style.display = 'none';
        return false;
    } else {
        isLandscapeMode = false;
        warning.style.display = 'none';
        if (controlsHint && isGameActive) controlsHint.style.display = 'block';
        return true;
    }
}

window.addEventListener('resize', checkOrientation);
window.addEventListener('orientationchange', checkOrientation);

// ========== МЕНЮ И УПРАВЛЕНИЕ ИГРОЙ ==========
const menu = document.getElementById('menu');
const startBtn = document.getElementById('start-game');
const modeButtons = document.querySelectorAll('.mode-btn');
const gameModeIndicator = document.getElementById('game-mode-indicator');
const p2Controls = document.getElementById('p2-controls');
const controlsHint = document.querySelector('.controls-hint');
const difficultyModal = document.getElementById('difficulty-modal');
const diffButtons = difficultyModal.querySelectorAll('.diff-btn');
const confirmDifficultyBtn = document.getElementById('confirm-difficulty');

// Выбор режима игры
modeButtons.forEach(btn => {
    btn.addEventListener('click', () => {
        if (isLandscapeMode || btn.classList.contains('disabled')) return;
        
        modeButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        selectedMode = btn.dataset.mode;
        
        const modeNames = {
            'pvp': '1 на 1 (PvP)',
            'pve': 'Против ИИ (PvE)',
            'survival': 'Выживание'
        };
        gameModeIndicator.textContent = modeNames[selectedMode];
    });
});

// Выбор сложности в модальном окне
diffButtons.forEach(btn => {
    btn.addEventListener('click', () => {
        diffButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        aiDifficulty = btn.dataset.diff;
    });
});

// Подтверждение выбора сложности
confirmDifficultyBtn.addEventListener('click', () => {
    difficultyModal.style.display = 'none';
    gameMode = 'pve';
    startActualGame();
});

// Нажатие на кнопку "Начать игру"
startBtn.addEventListener('click', () => {
    if (isLandscapeMode) return;
    
    if (selectedMode === 'pve') {
        difficultyModal.style.display = 'flex';
    } else if (selectedMode === 'pvp') {
        gameMode = 'pvp';
        startActualGame();
    } else if (selectedMode === 'survival') {
        alert('Режим "Выживание" находится в разработке. Выберите другой режим.');
    }
});

const backBtn = document.createElement('button');
backBtn.className = 'back-btn';
backBtn.textContent = 'В меню';
backBtn.style.display = 'none';
document.body.appendChild(backBtn);

backBtn.addEventListener('click', () => {
    returnToMenu();
});

// ========== СИСТЕМА УПРАВЛЕНИЯ (ИСПРАВЛЕННАЯ) ==========
class ControlSystem {
    constructor() {
        this.joyActivePointers = new Map();
        this.fireActivePointers = new Map();
    }
    
    initPlayerControls(joyId, fireId, playerIndex) {
        const joy = document.getElementById(joyId);
        const fire = document.getElementById(fireId);
        
        // Получаем стик
        const stick = joy.querySelector('.stick');
        
        const tank = tanks[playerIndex];
        const playerType = playerIndex === 0 ? 'p1' : 'p2';
        
        // Очищаем старые обработчики
        joy.onpointerdown = null;
        joy.onpointermove = null;
        joy.onpointerup = null;
        joy.onpointercancel = null;
        fire.onpointerdown = null;
        fire.onpointerup = null;
        fire.onpointercancel = null;
        
        // Джойстик
        joy.addEventListener('pointerdown', (e) => {
            e.preventDefault();
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            const pointerId = e.pointerId;
            this.joyActivePointers.set(pointerId, playerType);
            joy.setPointerCapture(pointerId);
            this.handleJoyMove(e, joy, stick, tank);
        });
        
        joy.addEventListener('pointermove', (e) => {
            e.preventDefault();
            if (this.joyActivePointers.has(e.pointerId)) {
                this.handleJoyMove(e, joy, stick, tank);
            }
        });
        
        joy.addEventListener('pointerup', (e) => {
            e.preventDefault();
            const pointerId = e.pointerId;
            
            if (this.joyActivePointers.get(pointerId) === playerType) {
                stick.style.transform = '';
                tank.dx = 0;
                tank.dy = 0;
                this.joyActivePointers.delete(pointerId);
            }
        });
        
        joy.addEventListener('pointercancel', (e) => {
            e.preventDefault();
            const pointerId = e.pointerId;
            
            if (this.joyActivePointers.get(pointerId) === playerType) {
                stick.style.transform = '';
                tank.dx = 0;
                tank.dy = 0;
                this.joyActivePointers.delete(pointerId);
            }
        });
        
        // Кнопка огня
        fire.addEventListener('pointerdown', (e) => {
            e.preventDefault();
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            const pointerId = e.pointerId;
            this.fireActivePointers.set(pointerId, playerType);
            fire.style.backgroundColor = 'rgba(255,255,255,0.3)';
            
            handleSOS(playerIndex, true);
            
            if (tank.isAlive) {
                const now = Date.now();
                if (now - tank.lastShotTime > tank.shootCooldown) {
                    bullets.push({
                        x: tank.x + Math.cos(tank.angle) * 30,
                        y: tank.y + Math.sin(tank.angle) * 30,
                        angle: tank.angle,
                        owner: tank.id,
                        isFromSOS: false
                    });
                    AudioManager.playShoot();
                    tank.lastShotTime = now;
                }
            }
        });
        
        fire.addEventListener('pointerup', (e) => {
            e.preventDefault();
            const pointerId = e.pointerId;
            
            if (this.fireActivePointers.get(pointerId) === playerType) {
                fire.style.backgroundColor = '';
                handleSOS(playerIndex, false);
                this.fireActivePointers.delete(pointerId);
            }
        });
        
        fire.addEventListener('pointercancel', (e) => {
            e.preventDefault();
            const pointerId = e.pointerId;
            
            if (this.fireActivePointers.get(pointerId) === playerType) {
                fire.style.backgroundColor = '';
                this.fireActivePointers.delete(pointerId);
            }
        });
        
        joy.addEventListener('contextmenu', e => e.preventDefault());
        fire.addEventListener('contextmenu', e => e.preventDefault());
    }
    
    handleJoyMove(e, joy, stick, tank) {
        const rect = joy.getBoundingClientRect();
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;
        
        const rawX = e.clientX - (rect.left + centerX);
        const rawY = e.clientY - (rect.top + centerY);
        
        const maxDistance = centerX - 10;
        const distance = Math.min(maxDistance, Math.hypot(rawX, rawY));
        const angle = Math.atan2(rawY, rawX);
        
        const scale = distance / (Math.hypot(rawX, rawY) || 1);
        stick.style.transform = `translate(${rawX * scale}px, ${rawY * scale}px)`;
        
        if (distance > 10) {
            tank.dx = Math.cos(angle) * (distance / maxDistance);
            tank.dy = Math.sin(angle) * (distance / maxDistance);
            tank.angle = angle;
        } else {
            tank.dx = 0;
            tank.dy = 0;
        }
    }
    
    clearAll() {
        this.joyActivePointers.clear();
        this.fireActivePointers.clear();
        
        if (tanks && tanks.length > 0) {
            tanks.forEach(tank => {
                tank.dx = 0;
                tank.dy = 0;
            });
        }
        
        document.querySelectorAll('.stick').forEach(stick => {
            if (stick) stick.style.transform = '';
        });
        
        document.querySelectorAll('.btn-fire').forEach(btn => {
            if (btn) btn.style.backgroundColor = '';
        });
    }
}

const controlSystem = new ControlSystem();

// ========== ФУНКЦИИ ЗАПУСКА ИГРЫ ==========
function startActualGame() {
    menu.style.display = 'none';
    gameModeIndicator.style.display = 'block';
    backBtn.style.display = 'block';
    controlsHint.style.display = 'block';
    
    if (gameMode === 'pve') {
        p2Controls.style.display = 'none';
    } else {
        p2Controls.style.display = 'block';
    }
    
    initGame();
    isGameActive = true;
}

function returnToMenu() {
    menu.style.display = 'flex';
    gameModeIndicator.style.display = 'none';
    backBtn.style.display = 'none';
    controlsHint.style.display = 'none';
    
    isGameActive = false;
    bullets = [];
    particles = [];
    sosTanks = [];
    
    controlSystem.clearAll();
    
    p2Controls.style.display = 'block';
}

// ========== ИНИЦИАЛИЗАЦИЯ ИГРЫ ==========
function initGame() {
    bullets = [];
    particles = [];
    sosTanks = [];
    tanks = [];
    
    if (gameMode === 'pvp') {
        tanks.push(new Tank(0, '#2e7d32', true));
        tanks.push(new Tank(1, '#c62828', false));
    } else if (gameMode === 'pve') {
        tanks.push(new Tank(0, '#2e7d32', true));
        const aiTank = new Tank(1, '#c62828', false, true);
        tanks.push(aiTank);
        aiPlayer = new AI(aiTank, aiDifficulty);
    }
    
    tanks.forEach(tank => tank.score = 0);
    updateScoreDisplay();
    createBricks();
    
    controlSystem.initPlayerControls('p1-joy', 'p1-fire', 0);
    if (gameMode !== 'pve') {
        controlSystem.initPlayerControls('p2-joy', 'p2-fire', 1);
    }
}

// ========== АУДИО МЕНЕДЖЕР ==========
const AudioManager = {
    play(frequency, type, duration) {
        if (audioCtx.state === 'suspended') return;
        
        try {
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            oscillator.type = type;
            oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
            
            gainNode.gain.setValueAtTime(CONFIG.AUDIO.VOLUME, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + duration);
        } catch (error) {
            console.warn('Audio error:', error);
        }
    },
    
    playBulletHit() {
        this.play(250, 'square', 0.05);
    },
    
    playTankHit() {
        this.play(160, 'sawtooth', 0.1);
    },
    
    playShoot() {
        this.play(120, 'triangle', 0.1);
    }
};

// ========== СОЗДАНИЕ УКРЫТИЙ ==========
function createBricks() {
    bricks = [];
    
    function addBrickWall(xStart, yStart, widthInBricks, heightInBricks) {
        for (let col = 0; col < widthInBricks; col++) {
            for (let row = 0; row < heightInBricks; row++) {
                bricks.push({
                    x: xStart + col * CONFIG.BRICK.WIDTH,
                    y: yStart + row * CONFIG.BRICK.HEIGHT,
                    w: CONFIG.BRICK.WIDTH,
                    h: CONFIG.BRICK.HEIGHT
                });
            }
        }
    }
    
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    
    // Центральные укрытия
    addBrickWall(centerX - 50, centerY - 60, 4, 2);
    addBrickWall(centerX - 50, centerY + 40, 4, 2);
    
    // Боковые укрытия
    addBrickWall(80, centerY - 30, 2, 3); // Слева
    addBrickWall(canvas.width - 130, centerY - 30, 2, 3); // Справа
}

// ========== ОТРИСОВКА ТАНКОВ (ИСПРАВЛЕНА) ==========
function drawTank(tank, isSOSTank = false) {
    if (!tank) return;
    
    ctx.save();
    ctx.translate(tank.x, tank.y);
    ctx.rotate(tank.angle);
    
    // Гусеницы
    ctx.fillStyle = '#111';
    ctx.fillRect(-18, -15, 36, 6);
    ctx.fillRect(-18, 9, 36, 6);
    
    // Корпус
    ctx.fillStyle = tank.color;
    ctx.beginPath();
    ctx.roundRect(-15, -10, 30, 20, 3);
    ctx.fill();
    
    // Центральная точка
    ctx.beginPath();
    ctx.arc(-2, 0, 8, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    
    // Дуло
    ctx.fillStyle = (tank.slow < 1 && !isSOSTank) ? '#00fbff' : '#222';
    ctx.fillRect(6, -2, 18, 4);
    
    // Индикатор ИИ
    if (tank.isAI && !isSOSTank) {
        ctx.fillStyle = '#ffcc00';
        ctx.font = '10px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('ИИ', -2, -15);
    }
    
    ctx.restore();
    
    // Полоска здоровья
    if (!isSOSTank && tank.isAlive) {
        const healthBarWidth = 35;
        const healthBarHeight = 5;
        const healthBarDistance = 28;
        const healthBarAngle = tank.angle + Math.PI;
        
        const healthBarX = tank.x + Math.cos(healthBarAngle) * healthBarDistance - healthBarWidth / 2;
        const healthBarY = tank.y + Math.sin(healthBarAngle) * healthBarDistance - healthBarHeight / 2;
        
        ctx.fillStyle = '#000';
        ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);
        
        const healthRatio = tank.hp / tank.maxHp;
        ctx.fillStyle = tank.hp > 1 ? '#0f0' : '#f00';
        ctx.fillRect(healthBarX, healthBarY, healthBarWidth * healthRatio, healthBarHeight);
    }
}

function drawBrick(brick) {
    ctx.fillStyle = CONFIG.BRICK.COLOR;
    ctx.fillRect(brick.x, brick.y, brick.w, brick.h);
    
    ctx.strokeStyle = CONFIG.BRICK.BORDER_COLOR;
    ctx.strokeRect(brick.x, brick.y, brick.w, brick.h);
    
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fillRect(brick.x + brick.w - 6, brick.y + 2, 4, brick.h - 4);
}

// ========== ОБНОВЛЕНИЕ ИГРЫ ==========
function updateTanks() {
    if (!tanks || tanks.length === 0) return;
    
    tanks.forEach(tank => {
        if (!tank.isAlive) return;
        
        if (tank.dx !== 0 || tank.dy !== 0) {
            const newX = tank.x + tank.dx * CONFIG.TANK.SPEED * tank.slow;
            const newY = tank.y + tank.dy * CONFIG.TANK.SPEED * tank.slow;
            
            const isColliding = bricks.some(brick => 
                newX + CONFIG.TANK.RADIUS > brick.x &&
                newX - CONFIG.TANK.RADIUS < brick.x + brick.w &&
                newY + CONFIG.TANK.RADIUS > brick.y &&
                newY - CONFIG.TANK.RADIUS < brick.y + brick.h
            );
            
            const isInBounds = 
                newX > CONFIG.TANK.RADIUS &&
                newX < canvas.width - CONFIG.TANK.RADIUS &&
                newY > CONFIG.TANK.RADIUS &&
                newY < canvas.height - CONFIG.TANK.RADIUS;
            
            if (!isColliding && isInBounds) {
                tank.x = newX;
                tank.y = newY;
            }
        }
        
        if (tank.slow < 1) {
            tank.slow += CONFIG.TANK.SLOW_RECOVERY;
        }
        
        drawTank(tank);
    });
}

function updateAI() {
    if (gameMode !== 'pve' || !aiPlayer || !tanks || tanks.length < 2 || !tanks[1] || !tanks[0]) return;
    
    const now = Date.now();
    if (now - lastAIUpdate > CONFIG.AI.UPDATE_INTERVAL) {
        aiPlayer.update(tanks[0]);
        lastAIUpdate = now;
    }
    
    if (aiPlayer.dodgeTimer > 0) {
        aiPlayer.dodgeTimer--;
    }
}

function updateSOSTanks() {
    for (let i = sosTanks.length - 1; i >= 0; i--) {
        const sosTank = sosTanks[i];
        if (!tanks || tanks.length < 2) continue;
        
        const target = tanks[1 - sosTank.owner];
        if (!target) continue;
        
        const distance = Math.hypot(target.x - sosTank.x, target.y - sosTank.y);
        
        if (distance > 50) {
            const newX = sosTank.x + Math.cos(sosTank.angle) * CONFIG.SOS.TANK_SPEED;
            const newY = sosTank.y + Math.sin(sosTank.angle) * CONFIG.SOS.TANK_SPEED;
            
            const isColliding = bricks.some(brick => 
                newX + 15 > brick.x &&
                newX - 15 < brick.x + brick.w &&
                newY + 15 > brick.y &&
                newY - 15 < brick.y + brick.h
            );
            
            if (!isColliding) {
                sosTank.angle = Math.atan2(target.y - sosTank.y, target.x - sosTank.x);
                sosTank.x = newX;
                sosTank.y = newY;
            }
        }
        
        drawTank(sosTank, true);
        
        if (Math.random() < 0.015) {
            bullets.push({
                x: sosTank.x,
                y: sosTank.y,
                angle: sosTank.angle,
                owner: sosTank.owner,
                isFromSOS: true
            });
        }
        
        sosTank.life--;
        if (sosTank.life <= 0) {
            sosTanks.splice(i, 1);
        }
    }
}

function updateBullets() {
    for (let i = bullets.length - 1; i >= 0; i--) {
        const bullet = bullets[i];
        
        bullet.x += Math.cos(bullet.angle) * CONFIG.BULLET.SPEED;
        bullet.y += Math.sin(bullet.angle) * CONFIG.BULLET.SPEED;
        
        ctx.fillStyle = bullet.isFromSOS ? CONFIG.BULLET.SOS_COLOR : CONFIG.BULLET.PLAYER_COLOR;
        ctx.beginPath();
        ctx.arc(bullet.x, bullet.y, CONFIG.BULLET.RADIUS, 0, Math.PI * 2);
        ctx.fill();
        
        const hitBrick = bricks.some(brick => 
            bullet.x > brick.x &&
            bullet.x < brick.x + brick.w &&
            bullet.y > brick.y &&
            bullet.y < brick.y + brick.h
        );
        
        if (hitBrick) {
            bullets.splice(i, 1);
            AudioManager.playBulletHit();
            continue;
        }
        
        let hitTank = false;
        
        for (const tank of tanks) {
            if (!tank || bullet.owner === tank.id || !tank.isAlive) continue;
            
            const distance = Math.hypot(bullet.x - tank.x, bullet.y - tank.y);
            
            if (distance < 20) {
                hitTank = true;
                tank.hp--;
                
                if (bullet.isFromSOS) {
                    tank.slow = 0.3;
                }
                
                AudioManager.playTankHit();
                
                if (tank.hp <= 0) {
                    if (!bullet.isFromSOS) {
                        if (tanks[bullet.owner]) {
                            tanks[bullet.owner].score++;
                            updateScoreDisplay();
                        }
                    }
                    
                    createExplosion(tank.x, tank.y);
                    
                    tank.hp = tank.maxHp;
                    tank.slow = 1;
                    tank.x = tank.isLeftPlayer ? 100 : canvas.width - 100;
                    tank.y = canvas.height / 2;
                    tank.angle = tank.isLeftPlayer ? 0 : Math.PI;
                }
                
                break;
            }
        }
        
        if (hitTank) {
            bullets.splice(i, 1);
            continue;
        }
        
        if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
            bullets.splice(i, 1);
        }
    }
}

function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];
        
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.alpha -= CONFIG.PARTICLES.FADE_SPEED;
        
        ctx.fillStyle = `rgba(${particle.color}, ${particle.alpha})`;
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
        ctx.fill();
        
        if (particle.alpha <= 0) {
            particles.splice(i, 1);
        }
    }
}

function createExplosion(x, y) {
    for (let i = 0; i < CONFIG.PARTICLES.COUNT_ON_EXPLOSION; i++) {
        particles.push({
            x: x,
            y: y,
            vx: (Math.random() - 0.5) * 4,
            vy: (Math.random() - 0.5) * 4,
            alpha: 1,
            radius: 3,
            color: '255,100,0'
        });
    }
}

function updateScoreDisplay() {
    if (tanks && tanks.length > 0) {
        document.getElementById('score1').textContent = tanks[0] ? tanks[0].score : 0;
        document.getElementById('score2').textContent = tanks[1] ? tanks[1].score : 0;
    }
}

// ========== ОБРАБОТКА SOS ==========
function handleSOS(playerIndex, isDown) {
    if (!tanks || !tanks[playerIndex]) return;
    
    const tank = tanks[playerIndex];
    const now = Date.now();
    
    if (isDown) {
        tank.lastDownTime = now;
    } else {
        const duration = now - tank.lastDownTime;
        let signalType = null;
        
        if (duration < 250) {
            signalType = '.';
        } else if (duration > 400) {
            signalType = '-';
        }
        
        if (signalType) {
            tank.sosBuffer.push(signalType);
            
            if (tank.sosBuffer.length > 9) {
                tank.sosBuffer.shift();
            }
            
            if (tank.sosBuffer.join('') === '...---...') {
                spawnSOS(playerIndex);
                tank.sosBuffer = [];
            }
        }
    }
}

function spawnSOS(playerIndex) {
    if (!tanks || !tanks[playerIndex]) return;
    
    const sides = [
        { x: canvas.width / 2, y: -60 },
        { x: canvas.width / 2, y: canvas.height + 60 },
        { x: -60, y: canvas.height / 2 },
        { x: canvas.width + 60, y: canvas.height / 2 }
    ];
    
    for (let i = 0; i < CONFIG.SOS.TANK_COUNT; i++) {
        const side = sides[i % 4];
        sosTanks.push({
            x: side.x + (Math.random() - 0.5) * 40,
            y: side.y + (Math.random() - 0.5) * 40,
            angle: 0,
            color: tanks[playerIndex].color,
            owner: playerIndex,
            life: 600
        });
    }
}

// ========== ИГРОВОЙ ЦИКЛ ==========
function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    if (tanks && tanks.length > 0) {
        tanks.forEach(tank => {
            tank.x = tank.isLeftPlayer ? 100 : canvas.width - 100;
            tank.y = canvas.height / 2;
        });
    }
    
    createBricks();
}

function gameLoop() {
    if (!isGameActive) return;
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Отрисовываем кирпичи
    bricks.forEach(drawBrick);
    
    // Обновляем игровые объекты
    updateTanks();
    updateAI();
    updateSOSTanks();
    updateBullets();
    updateParticles();
    
    requestAnimationFrame(gameLoop);
}

// ========== ЗАПУСК ИГРЫ ==========
window.addEventListener('load', () => {
    resizeCanvas();
    checkOrientation();
    menu.style.display = 'flex';
    gameLoop();
});

window.addEventListener('resize', resizeCanvas);

document.addEventListener('gesturestart', e => e.preventDefault());
document.addEventListener('gesturechange', e => e.preventDefault());
document.addEventListener('gestureend', e => e.preventDefault());
document.addEventListener('selectstart', e => e.preventDefault());
</script>
</body>
</html>
